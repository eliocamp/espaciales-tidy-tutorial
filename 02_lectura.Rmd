---
title: "Lectura de datos"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Datos en .csv, .txt, etc

Si de casualidad los datos que vas a usar están en un formato de texto o excel, podés usar cualquier función para leerlos que te resulte cómoda.
Cómo siempre es importante tener presente el tipo de dato de cada columna, sobre todo si son datos desconocidos.
¿Tiene columnas con latitudes y longitudes?
¿Están en formato decimal o en grados y minutos?
¿R leyó estas columnas como número o texto?

De alguna manera este es un punto en contra para este tipo de formatos, no tienen metadatos asociados o al menos *no vienen con el archivo*.
En la próxima sección presentaremos un tipo de archivo que si cumple con estas cosas.

## Datos en netCDF

Uno de estos tipos de formatos muy utilizado en ciencias para guardar datos atmosféricos grillados es el netCDF.
La página web de unidata describe al formato netCDF como:

-   Auto-descriptivo: Un netCDF contiene información sobre los datos que contiene

-   Portable: Un archivo netCDF puede ser accedido por computadoras que almacenan enteros, caracteres y números de punto flotante de forma diferente.

-   Escalable: Se puede acceder eficientemente a pequeños subsets de grandes bases de datos, incluso desde servidores remotos.

-   Anexable: Se pueden añadir nuevos datos pueden añadirse a un archivo netCDF correctamente estructurado sin copiar el conjunto de datos ni redefinir su estructura.

-   Compartible.
    Un escritor y varios lectores pueden acceder simultáneamente al mismo archivo netCDF.

-   Archivable.
    El acceso a todas las formas anteriores de datos netCDF será compatible con las versiones actuales y futuras del software.

Todo ese márketing lo que significa en la práctica es que los datos en netCDF son muy cómodos porque tienen los metadatos incluídos y porque es muy fácil leer sólo las partes necesarias.
Existen muchos paquetes de R para leer (y escribir) archivos en este formato.
En este tutorial vamos a usar **metR**.

Los datos en archivos NetCDF puede ser bastante grandes y destruir tu sesión de R si tratás de leerlos enteros en memoria.
Por eso, siempre es bueno primero fijarse qué tiene un archivo nuevo.
Para eso, metR tiene la función GlanceNetCDF que muestra un vistazo de los metadatos del archivo.
Vamos a trabajar con un archivo en este formato que contiene datos de reanálisis del NCEP.

```{r}
library(metR)
# Archivo que viene con metR
archivo <- system.file("extdata", "temperature.nc", package = "metR")

metR::GlanceNetCDF(archivo)
```

La salida de esta función muestra las variables que tiene el archivo y sus dimensiones.

::: {.alert .alert-info}
¿Qué información podés deducir sobre el contenido del archivo a partir de esto?
:::

En este caso, el archivo tiene una sola variable, llamada `air` que es la temperatura media en Kelvin (un archivo netCDF puede tener muchas variables y no todas en la misma grilla).
De las dimensiones del archivo, se ve que tiene dimensiones de tiempo, nivel, longitud y latitud.
La latitud va de -90 a 90 y la longitud de 0 a 357.5, por lo que es un campo global.
`level` es la coordenada vertical, que va de 1000 milibares (básicamente la superficie) a 10 millibares (la estratósfera media).

Podemos hacer la cuenta de cuántas observaciones tiene este archivo:

```{r}
1*17*73*144
```

Que puede leerse sin problema.

Para leer los datos, se usa `ReadNetCDF()`.

```{r}
temperatura <- ReadNetCDF(archivo)
temperatura
```

## Leyendo variables

```{r include=FALSE}
archivo <- "datos/temperatura_mar.nc"
```


Y ahora podemos leer sin problemas.
`ReadNetCDF()` por default trata de leer todas las variables, una en cada columna.
Eso no siempre es posible o deseable, porque distintas variables pueden tener distintas dimensiones; como por ejemplo, si hay variables definidias en 2D mezcladas con variables definidas en 3D.
Entonces lo que se puede hacer es elegir qué variables leer con el argumento `vars`.

Leamos primero la temperatura de la superficie del mar:

```{r}
sst <- ReadNetCDF(archivo, vars = "sst")
head(sst)
```

Lo primero que a mí me gusta hacer cuando leo los datos es mirar el primer campo o un par de campos.
Va a haber más sobre los detalles para visualizar estos datos con ggplot2 más adelante, pero por ahora usemos el viejo y confiable `geom_raster()`.

```{r message=FALSE, warning=FALSE}
# Además, cargo los paquetes necesarios
library(magrittr)
library(ggplot2)
library(dplyr)
library(data.table)
```

##  {.tabset}

### data.table

```{r}
sst %>% 
  .[time == time[1]] %>%  
  ggplot(aes(longitude, latitude)) +
  geom_raster(aes(fill = sst)) 
```

### dplyr

```{r}
sst %>% 
  filter(time == time[1]) %>% 
  ggplot(aes(longitude, latitude)) +
  geom_raster(aes(fill = sst)) 
```

## 

En este gráfico ya se ven varias cosas.
Se ve que hay una clara estructura de mayores temperaturas cerca del ecuador, lo cual no debería sorprender a nadie.
También se ve que, como lo que estamos leyendo es la temperatura de la superficie del mar, tenemos datos faltantes sobre los continentes.
Esto puede molestar un poco para algunas operaciones, ¡pero nos viene bárbaro para tener el contorno de los continentes gratis!
Finalmente, notar que como las longitudes van de 0º a 360º (en vez de -180º a 180º), el mapa sale centrado en el Océano Pacífico.
Esto va a haber que tenerlo en cuenta cuando sea la hora de graficar los continentes con algo mejor que bloques grises.

## Leyendo regiones

Es muy común tener muchos datos en unos pocos archivos netCDF pero necesitar sólo una parte.
Por ejemplo, me voy a poner en los zapatos de un investigador neozelandés que le interese estudiar la temperatura de la superficie del mar cerca de Nueva Zelanda y sus islas cercanas.
En este caso, podría leer sólo una región acotada usando el argumento `subset` :

```{r}
ReadNetCDF(archivo, vars = "sst", 
           subset = list(longitude = c(100, 200),
                         latitude = c(0, -90))) %>% 
  .[time == time[1]] %>% 
  ggplot(aes(longitude, latitude)) +
  geom_raster(aes(fill = sst)) 
```

El argumento `subset` tiene que ser una lista cuyos elementos tienen los nombres de las dimensiones a usar para filtrar y cada elemento es un vector cuyo rango define el bloque de datos a leer.

En el código anterior subset es:

```{r, eval = FALSE}
list(longitude = c(100, 200),
     latitude = c(0, -90))
```

Lo que significa que se van a leer los datos con latitud entre -90º y 0º, y con longitud entre 100º y 200º.


::: {.alert .alert-info}
El argumento `subset` de `ReadNetCDF()` tiene otros aces bajo la manga, como usar `NA` para referirse al mínimo o al máximo valor posible en un rango a la hora de hacer un subset o leer regiones discontinuas de datos. Todo eso se puede leer en la ayuda: `?ReadNetCDF()`.
:::
